# JavaScript Event Loop

# setTimeout()

- 전역 setTimeout() 메서드는 만료된 후 함수나 지정한 코드 조각을 실행하는 타이머를 설정함

- 두 번째 매개변수로 들어간 밀리초 단위가 지난 후 첫 번째 매개변수인 콜백 함수 호출

```js
// 동기
console.log(1);

// 비동기
setTimeout(() => {
  console.log(2);
}, 3000);

// 동기
console.log(3);
```

<br />

## 동기 vs 비동기

- 동기(Synchronous): 시간을 맞춤

  ```
  - 대학생이 되는 법

  1. 대학교 입학
  2. 1학년
  3. 2학년
  4. 3학년
  ```

- 비동기(Asynchronous): 시간을 맞추지 않음

  ```
  - 취직하는 법

  1. 토익 공부
  2. 자격증 취득
  3. 영어 공부
  ```

> 둘의 차이: 동기는 이전의 것이 끝나야 다음 단계 진행 가능,<br />
> 비동기는 모든 단계를 순차적으로 동작하지 않아도 개별 진행 가능

<br />

## 자바스크립트의 비동기 동작

- 브라우저에서 사용한다면 브라우저 API를 사용하는 것(Window Object)

- Node에서 사용한다면 Node API를 사용하는 것(Global Object)

> 자바스크립트는 동기 언어기 때문에 외부의 도움을 받아서 비동기처럼 동작할 수 있음

<br />

## 자바스크립트 엔진

- 자바스크립트 코드를 실행하려면 자바스크립트 엔진이 필요

- 엔진은 두 가지 주요 구성 요소를 가짐

  1. 메모리 힙(Heap)

  - 동적 메모리 저장소: 객체, 배열, 함수 등 참조 타입 데이터가 저장되는 공간

  - 동적으로 크기 할당: 런타임 중에 크기가 변할 수 있는 데이터를 저장하며, 각 데이터는 고유한 주소(참조값)를 가짐

  - 가비지 컬렉션: 더 이상 사용되지 않는 데이터는 가비지 컬렉터가 자동으로 메모리에서 해제

  2. 호출 스택(Call Stack)

  - 코드 실행 흐름 관리: 함수 호출, 실행 컨텍스트, 지역 변수, 매개변수 등이 저장되는 공간

  - 원시 타입(Primitive Type) 저장: 숫자, 문자열, 불리언 등 원시 타입의 값이 스택에 직접 저장

  - LIFO 구조: 마지막에 들어온 데이터가 먼저 나가는 구조로, 함수 호출 시 스택 프레임이 쌓이고 함수 종료 시 제거

  > 원시 타입: 값 자체가 스택에 저장 <br />
  > 참조 타입(객체, 배열, 함수 등): 실제 데이터는 힙에 저장, 변수에는 참조값(주소)이 스택에 저장

<br />

## 브라우저

- JavaScript 엔진 이외에도 Web API들과 Callback Queue, Event Loop 존재

  1. 비동기 작업인 setTimeout은 Web API에서 처리

  2. setTimeout의 시간이 지나서 완료되면 콜백 큐로 함수가 들어오게 됨

  3. 콜백 큐에는 Web API의 콜백 함수들이 대기하게 됨

  4. 이벤트 루프는 call stack과 callback queue를 주시하고 있다가 call stack이 비게 되면 먼저 들어온 순서대로 callback queue에 있는 함수들을 call stack에 넣어줌

<br />

- 내부 진행되는 모습을 보여주는 사이트

  - http//latentflip.com/loupe

  - https://kamronbekshodmonov.github.io/JELoop-Visualizer
